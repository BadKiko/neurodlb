"""
Telegram bot implementation using aiogram.
AI-powered bot for video processing.
"""

import asyncio
import logging
from pathlib import Path
from typing import Optional, Dict, Any

from aiogram import Bot, Dispatcher, types, F
from aiogram.client.default import DefaultBotProperties
from aiogram.enums import ParseMode

from config import TELEGRAM_BOT_TOKEN, MISTRAL_API_KEY
from video_processor import VideoProcessor
from llm_handler import LLMHandler

logger = logging.getLogger(__name__)

# Global instances
video_processor = VideoProcessor()
llm_handler = LLMHandler(MISTRAL_API_KEY) if MISTRAL_API_KEY else None


def is_video_url(text: str) -> bool:
    """Check if text contains any valid URL."""
    import re
    from urllib.parse import urlparse

    url_pattern = r"https?://[^\s]+"
    urls = re.findall(url_pattern, text)

    for url in urls:
        try:
            parsed = urlparse(url)
            if parsed.scheme and parsed.netloc:
                return True
        except:
            continue
    return False


def extract_video_url(text: str) -> Optional[str]:
    """Extract first valid URL from text."""
    import re
    from urllib.parse import urlparse

    url_pattern = r"https?://[^\s]+"
    urls = re.findall(url_pattern, text)

    for url in urls:
        try:
            parsed = urlparse(url)
            if parsed.scheme and parsed.netloc:
                return url
        except:
            continue
    return None


def contains_trim_request(text: str) -> bool:
    """Check if text contains trim request."""
    text_lower = text.lower()
    trim_keywords = [
        "–æ–±—Ä–µ–∂—å", "–æ–±—Ä–µ–∑–∞—Ç—å", "trim", "cut",
        "—Å ", "–æ—Ç ", "–ø–æ ", "–¥–æ ",
        "—Å–µ–∫—É–Ω–¥", "–º–∏–Ω—É—Ç", "—Å–µ–∫", "–º–∏–Ω"
    ]
    return any(keyword in text_lower for keyword in trim_keywords)


async def start_command(message: types.Message) -> None:
    """
    Handle /start command.
    """
    user = message.from_user
    await message.reply(
        f"–ü—Ä–∏–≤–µ—Ç, {user.first_name}! ü§ñ\n\n"
        "–Ø –±–æ—Ç –¥–ª—è –æ–±—Ä–∞–±–æ—Ç–∫–∏ –≤–∏–¥–µ–æ —Å –ø–æ–º–æ—â—å—é –ò–ò.\n"
        "–û—Ç–ø—Ä–∞–≤—å –º–Ω–µ —Å—Å—ã–ª–∫—É –Ω–∞ –≤–∏–¥–µ–æ –∏ —è –ø–æ–º–æ–≥—É –µ–≥–æ –æ–±—Ä–∞–±–æ—Ç–∞—Ç—å!\n\n"
        "–ò—Å–ø–æ–ª—å–∑—É–π /help –¥–ª—è –ø–æ–¥—Ä–æ–±–Ω–æ–π –∏–Ω—Ñ–æ—Ä–º–∞—Ü–∏–∏."
    )
    logger.info(f"User {user.id} started bot")


async def help_command(message: types.Message) -> None:
    """
    Handle /help command.
    """
    user = message.from_user
    help_text = (
        "ü§ñ –Ø —É–º–Ω—ã–π –±–æ—Ç –¥–ª—è –æ–±—Ä–∞–±–æ—Ç–∫–∏ –≤–∏–¥–µ–æ!\n\n"
        "üìã –ß—Ç–æ —è —É–º–µ—é:\n"
        "‚Ä¢ üì• –°–∫–∞—á–∏–≤–∞—Ç—å –≤–∏–¥–µ–æ —Å –ª—é–±—ã—Ö –ø–ª–∞—Ç—Ñ–æ—Ä–º\n"
        "‚Ä¢ ‚úÇÔ∏è –û–±—Ä–µ–∑–∞—Ç—å –≤–∏–¥–µ–æ –ø–æ –≤—Ä–µ–º–µ–Ω–∏\n"
        "‚Ä¢ üß† –ü–æ–Ω–∏–º–∞—Ç—å –µ—Å—Ç–µ—Å—Ç–≤–µ–Ω–Ω—ã–π —è–∑—ã–∫ (—Å –ø–æ–º–æ—â—å—é –ò–ò)\n"
        "‚Ä¢ üéØ –ê–≤—Ç–æ–º–∞—Ç–∏—á–µ—Å–∫–∏ —Ä–∞—Å–ø–æ–∑–Ω–∞–≤–∞—Ç—å –∫–æ–º–∞–Ω–¥—ã\n\n"
        "üí° –ü—Ä–æ—Å—Ç–æ –Ω–∞–ø–∏—à–∏—Ç–µ —á—Ç–æ —Ö–æ—Ç–∏—Ç–µ —Å–¥–µ–ª–∞—Ç—å —Å –≤–∏–¥–µ–æ!\n\n"
        "üìù –ü—Ä–∏–º–µ—Ä—ã –∫–æ–º–∞–Ω–¥:\n"
        "‚Ä¢ https://youtube.com/watch?v=... - –ø—Ä–æ—Å—Ç–æ —Å–∫–∞—á–∞—Ç—å\n"
        "‚Ä¢ –°–∫–∞—á–∞–π —ç—Ç–æ –≤–∏–¥–µ–æ - —Å–∫–∞—á–∞—Ç—å —Å —Ä–∞—Å–ø–æ–∑–Ω–∞–≤–∞–Ω–∏–µ–º\n"
        "‚Ä¢ –û–±—Ä–µ–∂—å —Å 10 –ø–æ 20 —Å–µ–∫—É–Ω–¥—É - –æ–±—Ä–µ–∑–∞—Ç—å\n"
        "‚Ä¢ –°–∫–∞—á–∞–π –∏ –æ–±—Ä–µ–∂—å —Å 1:30 –¥–æ 2:45 - –≤—Å—ë –≤–º–µ—Å—Ç–µ\n"
        "‚Ä¢ https://vimeo.com/123 –æ—Ç 5 –¥–æ 15 - –ø–æ–ª–Ω—ã–π URL\n\n"
        "‚è∞ –§–æ—Ä–º–∞—Ç—ã –≤—Ä–µ–º–µ–Ω–∏:\n"
        "‚Ä¢ —Å 10 –ø–æ 20 (—Å–µ–∫—É–Ω–¥—ã)\n"
        "‚Ä¢ –æ—Ç 1:30 –¥–æ 2:45 (–º–∏–Ω—É—Ç—ã:—Å–µ–∫—É–Ω–¥—ã)\n"
        "‚Ä¢ —Å 5 –¥–æ 15\n\n"
        "üéØ –ë–æ—Ç –ø–æ–Ω–∏–º–∞–µ—Ç —Ä—É—Å—Å–∫–∏–π —è–∑—ã–∫ –∏ —Å–∞–º –æ–ø—Ä–µ–¥–µ–ª–∏—Ç —á—Ç–æ –¥–µ–ª–∞—Ç—å!"
    )
    await message.reply(help_text)
    logger.info(f"User {user.id} requested help")


async def handle_message(message: types.Message) -> None:
    """
    Handle incoming text messages using LLM analysis.
    """
    user = message.from_user
    text = message.text

    logger.info(f"Received message from {user.id}: {text}")

    # Use LLM for intelligent command analysis
    if llm_handler:
        await handle_llm_request(message, text)
    else:
        # Fallback to simple logic if no LLM available
        if is_video_url(text):
            await handle_video_request(message, text)
        elif contains_trim_request(text):
            await handle_trim_request(message, text)
        else:
            await message.reply("–ü—Ä–∏–≤–µ—Ç! ü§ñ")
            logger.info(f"Replied with greeting to user {user.id}")


async def handle_llm_request(message: types.Message, text: str) -> None:
    """
    Handle request using LLM analysis.

    Args:
        message: Telegram message
        text: User message text
    """
    user = message.from_user

    try:
        # Get LLM analysis
        llm_result = await llm_handler.process_request(text)

        logger.info(f"LLM analysis result: {llm_result}")

        action = llm_result["action"]
        confidence = llm_result["confidence"]

        # Check confidence level
        if confidence < 0.5:
            await message.reply(
                f"ü§î –ù–µ —É–≤–µ—Ä–µ–Ω –≤ –ø–æ–Ω–∏–º–∞–Ω–∏–∏ –∑–∞–ø—Ä–æ—Å–∞ (—É–≤–µ—Ä–µ–Ω–Ω–æ—Å—Ç—å: {confidence:.1%})\n\n"
                "–ü–æ–ø—Ä–æ–±—É–π—Ç–µ –ø–µ—Ä–µ—Ñ—Ä–∞–∑–∏—Ä–æ–≤–∞—Ç—å –∏–ª–∏ –∏—Å–ø–æ–ª—å–∑—É–π—Ç–µ /help –¥–ª—è –ø—Ä–∏–º–µ—Ä–æ–≤."
            )
            return

        # Process based on action
        if action == "download":
            await handle_download_action(message, llm_result["video_url"])

        elif action == "trim":
            await handle_trim_only_action(message, text)

        elif action == "download_and_trim":
            await handle_download_trim_action(message, llm_result)

        else:
            await message.reply("ü§∑‚Äç‚ôÇÔ∏è –ù–µ –ø–æ–Ω—è–ª –∑–∞–ø—Ä–æ—Å. –ò—Å–ø–æ–ª—å–∑—É–π—Ç–µ /help –¥–ª—è –ø—Ä–∏–º–µ—Ä–æ–≤.")

    except Exception as e:
        logger.error(f"Error in LLM request processing: {e}")
        # Fallback to simple logic
        await message.reply("ü§ñ –ò—Å–ø–æ–ª—å–∑—É—é –ø—Ä–æ—Å—Ç–æ–π —Ä–µ–∂–∏–º –æ–±—Ä–∞–±–æ—Ç–∫–∏...")

        if is_video_url(text):
            await handle_video_request(message, text)
        elif contains_trim_request(text):
            await handle_trim_request(message, text)
        else:
            await message.reply("–ü—Ä–∏–≤–µ—Ç! ü§ñ")


async def handle_download_action(message: types.Message, video_url: str) -> None:
    """
    Handle simple download action.

    Args:
        message: Telegram message
        video_url: Video URL to download
    """
    if not video_url:
        await message.reply("‚ùå –ù–µ –Ω–∞–π–¥–µ–Ω–∞ —Å—Å—ã–ª–∫–∞ –Ω–∞ –≤–∏–¥–µ–æ")
        return

    await handle_video_download(message, video_url)


async def handle_trim_only_action(message: types.Message, text: str) -> None:
    """
    Handle trim-only action (when no video URL provided).

    Args:
        message: Telegram message
        text: Original message text
    """
    await message.reply(
        "‚úÇÔ∏è –î–ª—è –æ–±—Ä–µ–∑–∫–∏ –≤–∏–¥–µ–æ –Ω—É–∂–Ω–∞ —Å—Å—ã–ª–∫–∞.\n\n"
        "–ü—Ä–∏—à–ª–∏—Ç–µ —Å–æ–æ–±—â–µ–Ω–∏–µ –≤ —Ñ–æ—Ä–º–∞—Ç–µ:\n"
        "‚Ä¢ –°–∫–∞—á–∞–π https://video-url.com –∏ –æ–±—Ä–µ–∂—å —Å 10 –ø–æ 20\n"
        "‚Ä¢ –û–±—Ä–µ–∂—å https://vimeo.com/123 —Å 1:30 –¥–æ 2:45"
    )


async def handle_download_trim_action(message: types.Message, llm_result: Dict[str, Any]) -> None:
    """
    Handle combined download and trim action.

    Args:
        message: Telegram message
        llm_result: LLM analysis result
    """
    video_url = llm_result["video_url"]
    start_time = llm_result["start_time"]
    end_time = llm_result["end_time"]

    if not video_url:
        await message.reply("‚ùå –ù–µ –Ω–∞–π–¥–µ–Ω–∞ —Å—Å—ã–ª–∫–∞ –Ω–∞ –≤–∏–¥–µ–æ")
        return

    if start_time is None or end_time is None:
        await message.reply("‚ùå –ù–µ —É–¥–∞–ª–æ—Å—å —Ä–∞—Å–ø–æ–∑–Ω–∞—Ç—å –≤—Ä–µ–º–µ–Ω–Ω–æ–π –∏–Ω—Ç–µ—Ä–≤–∞–ª")
        return

    await handle_video_download_trim(message, video_url, start_time, end_time)


async def handle_video_download(message: types.Message, video_url: str) -> None:
    """
    Simplified video download handler for LLM integration.

    Args:
        message: Telegram message
        video_url: Video URL to download
    """
    user = message.from_user

    logger.info(f"LLM-triggered download from {user.id}: {video_url}")

    # Send processing message
    processing_msg = await message.reply("‚è≥ –°–∫–∞—á–∏–≤–∞—é –≤–∏–¥–µ–æ...")

    try:
        # Get video info first
        video_info = await video_processor.get_video_info(video_url)
        if video_info:
            info_text = (
                f"üìπ –ù–∞–π–¥–µ–Ω–æ –≤–∏–¥–µ–æ:\n"
                f"üé¨ {video_info['title']}\n"
                f"üë§ {video_info['uploader']}\n"
                f"‚è±Ô∏è {video_info['duration']} —Å–µ–∫\n\n"
                f"üîÑ –ù–∞—á–∏–Ω–∞—é —Å–∫–∞—á–∏–≤–∞–Ω–∏–µ..."
            )
            await processing_msg.edit_text(info_text)

        # Download video
        video_path = await video_processor.download_video(video_url)

        if video_path and Path(video_path).exists():
            # Check file size
            file_size = Path(video_path).stat().st_size
            max_size = 50 * 1024 * 1024  # 50MB

            if file_size > max_size:
                await processing_msg.edit_text(
                    f"‚ùå –í–∏–¥–µ–æ —Å–ª–∏—à–∫–æ–º –±–æ–ª—å—à–æ–µ ({file_size // (1024*1024)}MB).\n"
                    f"Telegram –æ–≥—Ä–∞–Ω–∏—á–∏–≤–∞–µ—Ç —Ä–∞–∑–º–µ—Ä —Ñ–∞–π–ª–∞ –¥–æ 50MB."
                )
            else:
                # Send video
                await processing_msg.edit_text("üì§ –û—Ç–ø—Ä–∞–≤–ª—è—é –≤–∏–¥–µ–æ...")
                await message.reply_video(
                    video=types.input_file.FSInputFile(video_path),
                    caption="‚úÖ –í–∏–¥–µ–æ —É—Å–ø–µ—à–Ω–æ —Å–∫–∞—á–∞–Ω–æ!"
                )
                await processing_msg.delete()

            # Clean up file
            if Path(video_path).exists():
                try:
                    Path(video_path).unlink()
                    logger.info(f"Cleaned up video file: {video_path}")
                except Exception as e:
                    logger.error(f"Error cleaning up file {video_path}: {e}")

        else:
            await processing_msg.edit_text("‚ùå –ù–µ —É–¥–∞–ª–æ—Å—å —Å–∫–∞—á–∞—Ç—å –≤–∏–¥–µ–æ. –ü—Ä–æ–≤–µ—Ä—å—Ç–µ —Å—Å—ã–ª–∫—É.")

    except Exception as e:
        logger.error(f"Error in video download: {e}")
        await processing_msg.edit_text("‚ùå –ü—Ä–æ–∏–∑–æ—à–ª–∞ –æ—à–∏–±–∫–∞ –ø—Ä–∏ —Å–∫–∞—á–∏–≤–∞–Ω–∏–∏ –≤–∏–¥–µ–æ.")


async def handle_video_download_trim(message: types.Message, video_url: str, start_time: int, end_time: int) -> None:
    """
    Simplified video download and trim handler for LLM integration.

    Args:
        message: Telegram message
        video_url: Video URL to download
        start_time: Start time in seconds
        end_time: End time in seconds
    """
    user = message.from_user

    logger.info(f"LLM-triggered download+trim from {user.id}: {video_url} ({start_time}s - {end_time}s)")

    # Start processing
    processing_msg = await message.reply("‚è≥ –û–±—Ä–∞–±–∞—Ç—ã–≤–∞—é –≤–∏–¥–µ–æ...")

    try:
        # Get video info first
        video_info = await video_processor.get_video_info(video_url)
        if video_info:
            info_text = (
                f"üìπ –ù–∞–π–¥–µ–Ω–æ –≤–∏–¥–µ–æ:\n"
                f"üé¨ {video_info['title']}\n"
                f"‚è±Ô∏è –û–±—Ä–µ–∑–∫–∞: {start_time}—Å–µ–∫ - {end_time}—Å–µ–∫\n\n"
                f"üîÑ –ù–∞—á–∏–Ω–∞—é —Å–∫–∞—á–∏–≤–∞–Ω–∏–µ..."
            )
            await processing_msg.edit_text(info_text)

        # Download video
        video_path = await video_processor.download_video(video_url)

        if video_path and Path(video_path).exists():
            await processing_msg.edit_text("‚úÇÔ∏è –û–±—Ä–µ–∑–∞—é –≤–∏–¥–µ–æ...")

            # Trim video
            trimmed_path = await video_processor.trim_video(video_path, start_time, end_time)

            if trimmed_path and Path(trimmed_path).exists():
                # Check file size
                file_size = Path(trimmed_path).stat().st_size
                max_size = 50 * 1024 * 1024  # 50MB

                if file_size > max_size:
                    await processing_msg.edit_text(
                        f"‚ùå –û–±—Ä–µ–∑–∞–Ω–Ω–æ–µ –≤–∏–¥–µ–æ —Å–ª–∏—à–∫–æ–º –±–æ–ª—å—à–æ–µ ({file_size // (1024*1024)}MB).\n"
                        f"–ü–æ–ø—Ä–æ–±—É–π—Ç–µ –º–µ–Ω—å—à–∏–π –≤—Ä–µ–º–µ–Ω–Ω–æ–π –∏–Ω—Ç–µ—Ä–≤–∞–ª."
                    )
                else:
                    # Send trimmed video
                    await processing_msg.edit_text("üì§ –û—Ç–ø—Ä–∞–≤–ª—è—é –æ–±—Ä–µ–∑–∞–Ω–Ω–æ–µ –≤–∏–¥–µ–æ...")
                    await message.reply_video(
                        video=types.input_file.FSInputFile(trimmed_path),
                        caption=f"‚úÖ –í–∏–¥–µ–æ –æ–±—Ä–µ–∑–∞–Ω–æ —Å {start_time} –ø–æ {end_time} —Å–µ–∫—É–Ω–¥—É!"
                    )
                    await processing_msg.delete()

                # Clean up files
                for path in [video_path, trimmed_path]:
                    if path and Path(path).exists():
                        try:
                            Path(path).unlink()
                            logger.info(f"Cleaned up file: {path}")
                        except Exception as e:
                            logger.error(f"Error cleaning up file {path}: {e}")

            else:
                await processing_msg.edit_text("‚ùå –ù–µ —É–¥–∞–ª–æ—Å—å –æ–±—Ä–µ–∑–∞—Ç—å –≤–∏–¥–µ–æ. –ü—Ä–æ–≤–µ—Ä—å—Ç–µ –≤—Ä–µ–º–µ–Ω–Ω–æ–π –∏–Ω—Ç–µ—Ä–≤–∞–ª.")
        else:
            await processing_msg.edit_text("‚ùå –ù–µ —É–¥–∞–ª–æ—Å—å —Å–∫–∞—á–∞—Ç—å –≤–∏–¥–µ–æ. –ü—Ä–æ–≤–µ—Ä—å—Ç–µ —Å—Å—ã–ª–∫—É.")

    except Exception as e:
        logger.error(f"Error in video download+trim: {e}")
        await processing_msg.edit_text("‚ùå –ü—Ä–æ–∏–∑–æ—à–ª–∞ –æ—à–∏–±–∫–∞ –ø—Ä–∏ –æ–±—Ä–∞–±–æ—Ç–∫–µ –≤–∏–¥–µ–æ.")


async def handle_video_request(message: types.Message, text: str) -> None:
    """
    Handle video download request (legacy function).

    Args:
        message: Telegram message
        text: Message text containing video URL
    """
    user = message.from_user
    video_url = extract_video_url(text)

    if not video_url:
        await message.reply("‚ùå –ù–µ —É–¥–∞–ª–æ—Å—å –Ω–∞–π—Ç–∏ —Å—Å—ã–ª–∫—É –Ω–∞ –≤–∏–¥–µ–æ")
        return

    logger.info(f"Processing video request from {user.id}: {video_url}")

    # Send processing message
    processing_msg = await message.reply("‚è≥ –°–∫–∞—á–∏–≤–∞—é –≤–∏–¥–µ–æ...")

    try:
        # Get video info first
        video_info = await video_processor.get_video_info(video_url)
        if video_info:
            info_text = (
                f"üìπ –ù–∞–π–¥–µ–Ω–æ –≤–∏–¥–µ–æ:\n"
                f"üé¨ {video_info['title']}\n"
                f"üë§ {video_info['uploader']}\n"
                f"‚è±Ô∏è {video_info['duration']} —Å–µ–∫\n\n"
                f"üîÑ –ù–∞—á–∏–Ω–∞—é —Å–∫–∞—á–∏–≤–∞–Ω–∏–µ..."
            )
            await processing_msg.edit_text(info_text)

        # Download video
        video_path = await video_processor.download_video(video_url)

        if video_path and Path(video_path).exists():
            # Check file size
            file_size = Path(video_path).stat().st_size
            max_size = 50 * 1024 * 1024  # 50MB

            if file_size > max_size:
                await processing_msg.edit_text(
                    f"‚ùå –í–∏–¥–µ–æ —Å–ª–∏—à–∫–æ–º –±–æ–ª—å—à–æ–µ ({file_size // (1024*1024)}MB).\n"
                    f"Telegram –æ–≥—Ä–∞–Ω–∏—á–∏–≤–∞–µ—Ç —Ä–∞–∑–º–µ—Ä —Ñ–∞–π–ª–∞ –¥–æ 50MB."
                )
            else:
                # Send video
                await processing_msg.edit_text("üì§ –û—Ç–ø—Ä–∞–≤–ª—è—é –≤–∏–¥–µ–æ...")
                await message.reply_video(
                    video=types.input_file.FSInputFile(video_path),
                    caption="‚úÖ –í–∏–¥–µ–æ —É—Å–ø–µ—à–Ω–æ —Å–∫–∞—á–∞–Ω–æ!"
                )
                await processing_msg.delete()

            # Clean up file
            if Path(video_path).exists():
                try:
                    Path(video_path).unlink()
                    logger.info(f"Cleaned up video file: {video_path}")
                except Exception as e:
                    logger.error(f"Error cleaning up file {video_path}: {e}")

        else:
            await processing_msg.edit_text("‚ùå –ù–µ —É–¥–∞–ª–æ—Å—å —Å–∫–∞—á–∞—Ç—å –≤–∏–¥–µ–æ. –ü—Ä–æ–≤–µ—Ä—å—Ç–µ —Å—Å—ã–ª–∫—É.")

    except Exception as e:
        logger.error(f"Error processing video request: {e}")
        await processing_msg.edit_text("‚ùå –ü—Ä–æ–∏–∑–æ—à–ª–∞ –æ—à–∏–±–∫–∞ –ø—Ä–∏ –æ–±—Ä–∞–±–æ—Ç–∫–µ –≤–∏–¥–µ–æ.")


async def handle_trim_request(message: types.Message, text: str) -> None:
    """
    Handle video trim request (legacy function).

    Args:
        message: Telegram message
        text: Message text containing trim request
    """
    user = message.from_user

    logger.info(f"Processing trim request from {user.id}: {text}")

    # Check if there's a video URL in the message
    video_url = extract_video_url(text)

    if video_url:
        # Combined request: download and trim
        await handle_combined_request(message, text, video_url)
    else:
        # Trim request without URL - ask for video
        await message.reply(
            "‚ùå –ù–µ –Ω–∞–π–¥–µ–Ω–∞ —Å—Å—ã–ª–∫–∞ –Ω–∞ –≤–∏–¥–µ–æ –¥–ª—è –æ–±—Ä–µ–∑–∫–∏.\n\n"
            "–û—Ç–ø—Ä–∞–≤—å—Ç–µ —Å–æ–æ–±—â–µ–Ω–∏–µ –≤ —Ñ–æ—Ä–º–∞—Ç–µ:\n"
            "‚Ä¢ https://video-url.com –æ–±—Ä–µ–∂—å —Å 10 –ø–æ 20\n"
            "‚Ä¢ –°–∫–∞—á–∞–π https://video-url.com –∏ –æ–±—Ä–µ–∂—å —Å 1:30 –¥–æ 2:45"
        )


async def handle_combined_request(message: types.Message, text: str, video_url: str) -> None:
    """
    Handle combined download and trim request (legacy function).

    Args:
        message: Telegram message
        text: Full message text
        video_url: Extracted video URL
    """
    user = message.from_user

    # Parse time range from text
    time_range = video_processor.parse_time_request(text)
    if not time_range:
        await message.reply(
            "‚ùå –ù–µ —É–¥–∞–ª–æ—Å—å —Ä–∞—Å–ø–æ–∑–Ω–∞—Ç—å –≤—Ä–µ–º–µ–Ω–Ω–æ–π –∏–Ω—Ç–µ—Ä–≤–∞–ª.\n\n"
            "–ò—Å–ø–æ–ª—å–∑—É–π—Ç–µ —Ñ–æ—Ä–º–∞—Ç—ã:\n"
            "‚Ä¢ —Å 10 –ø–æ 20 —Å–µ–∫—É–Ω–¥—É\n"
            "‚Ä¢ –æ—Ç 1:30 –¥–æ 2:45\n"
            "‚Ä¢ —Å 10 –¥–æ 20"
        )
        return

    start_time, end_time = time_range
    logger.info(f"Parsed time range for trimming: {start_time}s - {end_time}s")

    # Start processing
    processing_msg = await message.reply("‚è≥ –û–±—Ä–∞–±–∞—Ç—ã–≤–∞—é –∑–∞–ø—Ä–æ—Å –Ω–∞ –æ–±—Ä–µ–∑–∫—É –≤–∏–¥–µ–æ...")

    try:
        # Get video info first
        video_info = await video_processor.get_video_info(video_url)
        if video_info:
            info_text = (
                f"üìπ –ù–∞–π–¥–µ–Ω–æ –≤–∏–¥–µ–æ:\n"
                f"üé¨ {video_info['title']}\n"
                f"‚è±Ô∏è –û–±—Ä–µ–∑–∫–∞: {start_time}—Å–µ–∫ - {end_time}—Å–µ–∫\n\n"
                f"üîÑ –ù–∞—á–∏–Ω–∞—é —Å–∫–∞—á–∏–≤–∞–Ω–∏–µ –∏ –æ–±—Ä–µ–∑–∫—É..."
            )
            await processing_msg.edit_text(info_text)

        # Download video
        video_path = await video_processor.download_video(video_url)

        if video_path and Path(video_path).exists():
            await processing_msg.edit_text("‚úÇÔ∏è –û–±—Ä–µ–∑–∞—é –≤–∏–¥–µ–æ...")

            # Trim video
            trimmed_path = await video_processor.trim_video(video_path, start_time, end_time)

            if trimmed_path and Path(trimmed_path).exists():
                # Check file size
                file_size = Path(trimmed_path).stat().st_size
                max_size = 50 * 1024 * 1024  # 50MB

                if file_size > max_size:
                    await processing_msg.edit_text(
                        f"‚ùå –û–±—Ä–µ–∑–∞–Ω–Ω–æ–µ –≤–∏–¥–µ–æ —Å–ª–∏—à–∫–æ–º –±–æ–ª—å—à–æ–µ ({file_size // (1024*1024)}MB).\n"
                        f"–ü–æ–ø—Ä–æ–±—É–π—Ç–µ –º–µ–Ω—å—à–∏–π –≤—Ä–µ–º–µ–Ω–Ω–æ–π –∏–Ω—Ç–µ—Ä–≤–∞–ª."
                    )
                else:
                    # Send trimmed video
                    await processing_msg.edit_text("üì§ –û—Ç–ø—Ä–∞–≤–ª—è—é –æ–±—Ä–µ–∑–∞–Ω–Ω–æ–µ –≤–∏–¥–µ–æ...")
                    await message.reply_video(
                        video=types.input_file.FSInputFile(trimmed_path),
                        caption=f"‚úÖ –í–∏–¥–µ–æ –æ–±—Ä–µ–∑–∞–Ω–æ —Å {start_time} –ø–æ {end_time} —Å–µ–∫—É–Ω–¥—É!"
                    )
                    await processing_msg.delete()

                # Clean up files
                for path in [video_path, trimmed_path]:
                    if path and Path(path).exists():
                        try:
                            Path(path).unlink()
                            logger.info(f"Cleaned up file: {path}")
                        except Exception as e:
                            logger.error(f"Error cleaning up file {path}: {e}")

            else:
                await processing_msg.edit_text("‚ùå –ù–µ —É–¥–∞–ª–æ—Å—å –æ–±—Ä–µ–∑–∞—Ç—å –≤–∏–¥–µ–æ. –ü—Ä–æ–≤–µ—Ä—å—Ç–µ –≤—Ä–µ–º–µ–Ω–Ω–æ–π –∏–Ω—Ç–µ—Ä–≤–∞–ª.")
        else:
            await processing_msg.edit_text("‚ùå –ù–µ —É–¥–∞–ª–æ—Å—å —Å–∫–∞—á–∞—Ç—å –≤–∏–¥–µ–æ. –ü—Ä–æ–≤–µ—Ä—å—Ç–µ —Å—Å—ã–ª–∫—É.")

    except Exception as e:
        logger.error(f"Error processing combined request: {e}")
        await processing_msg.edit_text("‚ùå –ü—Ä–æ–∏–∑–æ—à–ª–∞ –æ—à–∏–±–∫–∞ –ø—Ä–∏ –æ–±—Ä–∞–±–æ—Ç–∫–µ –∑–∞–ø—Ä–æ—Å–∞. –ü–æ–ø—Ä–æ–±—É–π—Ç–µ –µ—â–µ —Ä–∞–∑.")


async def run_bot() -> None:
    """
    Run the Telegram bot using aiogram.
    """
    if not TELEGRAM_BOT_TOKEN:
        raise ValueError("TELEGRAM_BOT_TOKEN is not set")

    # Create bot and dispatcher
    bot = Bot(token=TELEGRAM_BOT_TOKEN, default=DefaultBotProperties(parse_mode=ParseMode.HTML))
    dp = Dispatcher()

    # Register handlers
    dp.message.register(start_command, commands=["start"])
    dp.message.register(help_command, commands=["help"])
    dp.message.register(handle_message, F.text)

    logger.info("ü§ñ Bot is running with aiogram...")

    # Start polling
    try:
        await dp.start_polling(bot)
    except Exception as e:
        logger.error(f"Bot polling error: {e}")
        raise
    """
    Handle /start command.
    """
    user = message.from_user
    await message.reply(
        f"–ü—Ä–∏–≤–µ—Ç, {user.first_name}! ü§ñ\n\n"
        "–Ø –±–æ—Ç –¥–ª—è –æ–±—Ä–∞–±–æ—Ç–∫–∏ –≤–∏–¥–µ–æ —Å –ø–æ–º–æ—â—å—é –ò–ò.\n"
        "–û—Ç–ø—Ä–∞–≤—å –º–Ω–µ —Å—Å—ã–ª–∫—É –Ω–∞ –≤–∏–¥–µ–æ –∏ —è –ø–æ–º–æ–≥—É –µ–≥–æ –æ–±—Ä–∞–±–æ—Ç–∞—Ç—å!\n\n"
        "–ò—Å–ø–æ–ª—å–∑—É–π /help –¥–ª—è –ø–æ–¥—Ä–æ–±–Ω–æ–π –∏–Ω—Ñ–æ—Ä–º–∞—Ü–∏–∏."
    )
    logger.info(f"User {user.id} started bot")


async def help_command(message: types.Message) -> None:
    """
    Handle /help command.
    """
    user = message.from_user
    help_text = (
        "ü§ñ –Ø —É–º–Ω—ã–π –±–æ—Ç –¥–ª—è –æ–±—Ä–∞–±–æ—Ç–∫–∏ –≤–∏–¥–µ–æ!\n\n"
        "üìã –ß—Ç–æ —è —É–º–µ—é:\n"
        "‚Ä¢ üì• –°–∫–∞—á–∏–≤–∞—Ç—å –≤–∏–¥–µ–æ —Å –ª—é–±—ã—Ö –ø–ª–∞—Ç—Ñ–æ—Ä–º\n"
        "‚Ä¢ ‚úÇÔ∏è –û–±—Ä–µ–∑–∞—Ç—å –≤–∏–¥–µ–æ –ø–æ –≤—Ä–µ–º–µ–Ω–∏\n"
        "‚Ä¢ üß† –ü–æ–Ω–∏–º–∞—Ç—å –µ—Å—Ç–µ—Å—Ç–≤–µ–Ω–Ω—ã–π —è–∑—ã–∫ (—Å –ø–æ–º–æ—â—å—é –ò–ò)\n"
        "‚Ä¢ üéØ –ê–≤—Ç–æ–º–∞—Ç–∏—á–µ—Å–∫–∏ —Ä–∞—Å–ø–æ–∑–Ω–∞–≤–∞—Ç—å –∫–æ–º–∞–Ω–¥—ã\n\n"
        "üí° –ü—Ä–æ—Å—Ç–æ –Ω–∞–ø–∏—à–∏—Ç–µ —á—Ç–æ —Ö–æ—Ç–∏—Ç–µ —Å–¥–µ–ª–∞—Ç—å —Å –≤–∏–¥–µ–æ!\n\n"
        "üìù –ü—Ä–∏–º–µ—Ä—ã –∫–æ–º–∞–Ω–¥:\n"
        "‚Ä¢ https://youtube.com/watch?v=... - –ø—Ä–æ—Å—Ç–æ —Å–∫–∞—á–∞—Ç—å\n"
        "‚Ä¢ –°–∫–∞—á–∞–π —ç—Ç–æ –≤–∏–¥–µ–æ - —Å–∫–∞—á–∞—Ç—å —Å —Ä–∞—Å–ø–æ–∑–Ω–∞–≤–∞–Ω–∏–µ–º\n"
        "‚Ä¢ –û–±—Ä–µ–∂—å —Å 10 –ø–æ 20 —Å–µ–∫—É–Ω–¥—É - –æ–±—Ä–µ–∑–∞—Ç—å\n"
        "‚Ä¢ –°–∫–∞—á–∞–π –∏ –æ–±—Ä–µ–∂—å —Å 1:30 –¥–æ 2:45 - –≤—Å—ë –≤–º–µ—Å—Ç–µ\n"
        "‚Ä¢ https://vimeo.com/123 –æ—Ç 5 –¥–æ 15 - –ø–æ–ª–Ω—ã–π URL\n\n"
        "‚è∞ –§–æ—Ä–º–∞—Ç—ã –≤—Ä–µ–º–µ–Ω–∏:\n"
        "‚Ä¢ —Å 10 –ø–æ 20 (—Å–µ–∫—É–Ω–¥—ã)\n"
        "‚Ä¢ –æ—Ç 1:30 –¥–æ 2:45 (–º–∏–Ω—É—Ç—ã:—Å–µ–∫—É–Ω–¥—ã)\n"
        "‚Ä¢ —Å 5 –¥–æ 15\n\n"
        "üéØ –ë–æ—Ç –ø–æ–Ω–∏–º–∞–µ—Ç —Ä—É—Å—Å–∫–∏–π —è–∑—ã–∫ –∏ —Å–∞–º –æ–ø—Ä–µ–¥–µ–ª–∏—Ç —á—Ç–æ –¥–µ–ª–∞—Ç—å!"
    )
    await message.reply(help_text)
    logger.info(f"User {user.id} requested help")


async def handle_message(message: types.Message) -> None:
    """
    Handle incoming text messages using LLM analysis.
    """
    user = message.from_user
    text = message.text

    logger.info(f"Received message from {user.id}: {text}")

    # Use LLM for intelligent command analysis
    if llm_handler:
        await handle_llm_request(message, text)
    else:
        # Fallback to simple logic if no LLM available
        if is_video_url(text):
            await handle_video_request(message, text)
        elif contains_trim_request(text):
            await handle_trim_request(message, text)
        else:
            await message.reply("–ü—Ä–∏–≤–µ—Ç! ü§ñ")
            logger.info(f"Replied with greeting to user {user.id}")


async def handle_llm_request(update: Update, text: str) -> None:
    """
    Handle request using LLM analysis.

    Args:
        update: Telegram update
        text: User message text
    """
    user = update.effective_user

    try:
        # Get LLM analysis
        llm_result = await llm_handler.process_request(text)

        logger.info(f"LLM analysis result: {llm_result}")

        action = llm_result["action"]
        confidence = llm_result["confidence"]

        # Check confidence level
        if confidence < 0.5:
            await update.message.reply_text(
                f"ü§î –ù–µ —É–≤–µ—Ä–µ–Ω –≤ –ø–æ–Ω–∏–º–∞–Ω–∏–∏ –∑–∞–ø—Ä–æ—Å–∞ (—É–≤–µ—Ä–µ–Ω–Ω–æ—Å—Ç—å: {confidence:.1%})\n\n"
                "–ü–æ–ø—Ä–æ–±—É–π—Ç–µ –ø–µ—Ä–µ—Ñ—Ä–∞–∑–∏—Ä–æ–≤–∞—Ç—å –∏–ª–∏ –∏—Å–ø–æ–ª—å–∑—É–π—Ç–µ /help –¥–ª—è –ø—Ä–∏–º–µ—Ä–æ–≤."
            )
            return

        # Process based on action
        if action == "download":
            await handle_download_action(update, llm_result["video_url"])

        elif action == "trim":
            await handle_trim_only_action(update, text)

        elif action == "download_and_trim":
            await handle_download_trim_action(update, llm_result)

        else:
            await update.message.reply_text(
                "ü§∑‚Äç‚ôÇÔ∏è –ù–µ –ø–æ–Ω—è–ª –∑–∞–ø—Ä–æ—Å. –ò—Å–ø–æ–ª—å–∑—É–π—Ç–µ /help –¥–ª—è –ø—Ä–∏–º–µ—Ä–æ–≤."
            )

    except Exception as e:
        logger.error(f"Error in LLM request processing: {e}")
        # Fallback to simple logic
        await update.message.reply_text("ü§ñ –ò—Å–ø–æ–ª—å–∑—É—é –ø—Ä–æ—Å—Ç–æ–π —Ä–µ–∂–∏–º –æ–±—Ä–∞–±–æ—Ç–∫–∏...")

        if is_video_url(text):
            await handle_video_request(update, text)
        elif contains_trim_request(text):
            await handle_trim_request(update, text)
        else:
            await update.message.reply_text("–ü—Ä–∏–≤–µ—Ç!")


async def handle_download_action(update: Update, video_url: str) -> None:
    """
    Handle simple download action.

    Args:
        update: Telegram update
        video_url: Video URL to download
    """
    if not video_url:
        await update.message.reply_text("‚ùå –ù–µ –Ω–∞–π–¥–µ–Ω–∞ —Å—Å—ã–ª–∫–∞ –Ω–∞ –≤–∏–¥–µ–æ")
        return

    await handle_video_download(update, video_url)


async def handle_trim_only_action(update: Update, text: str) -> None:
    """
    Handle trim-only action (when no video URL provided).

    Args:
        update: Telegram update
        text: Original message text
    """
    await update.message.reply_text(
        "‚úÇÔ∏è –î–ª—è –æ–±—Ä–µ–∑–∫–∏ –≤–∏–¥–µ–æ –Ω—É–∂–Ω–∞ —Å—Å—ã–ª–∫–∞.\n\n"
        "–ü—Ä–∏—à–ª–∏—Ç–µ —Å–æ–æ–±—â–µ–Ω–∏–µ –≤ —Ñ–æ—Ä–º–∞—Ç–µ:\n"
        "‚Ä¢ –°–∫–∞—á–∞–π https://video-url.com –∏ –æ–±—Ä–µ–∂—å —Å 10 –ø–æ 20\n"
        "‚Ä¢ –û–±—Ä–µ–∂—å https://vimeo.com/123 —Å 1:30 –¥–æ 2:45"
    )


async def handle_download_trim_action(
    update: Update, llm_result: Dict[str, Any]
) -> None:
    """
    Handle combined download and trim action.

    Args:
        update: Telegram update
        llm_result: LLM analysis result
    """
    video_url = llm_result["video_url"]
    start_time = llm_result["start_time"]
    end_time = llm_result["end_time"]

    if not video_url:
        await update.message.reply_text("‚ùå –ù–µ –Ω–∞–π–¥–µ–Ω–∞ —Å—Å—ã–ª–∫–∞ –Ω–∞ –≤–∏–¥–µ–æ")
        return

    if start_time is None or end_time is None:
        await update.message.reply_text("‚ùå –ù–µ —É–¥–∞–ª–æ—Å—å —Ä–∞—Å–ø–æ–∑–Ω–∞—Ç—å –≤—Ä–µ–º–µ–Ω–Ω–æ–π –∏–Ω—Ç–µ—Ä–≤–∞–ª")
        return

    await handle_video_download_trim(update, video_url, start_time, end_time)


async def handle_video_download(update: Update, video_url: str) -> None:
    """
    Simplified video download handler for LLM integration.

    Args:
        update: Telegram update
        video_url: Video URL to download
    """
    user = update.effective_user

    logger.info(f"LLM-triggered download from {user.id}: {video_url}")

    # Send processing message
    processing_msg = await update.message.reply_text("‚è≥ –°–∫–∞—á–∏–≤–∞—é –≤–∏–¥–µ–æ...")

    try:
        # Get video info first
        video_info = await video_processor.get_video_info(video_url)
        if video_info:
            info_text = (
                f"üìπ –ù–∞–π–¥–µ–Ω–æ –≤–∏–¥–µ–æ:\n"
                f"üé¨ {video_info['title']}\n"
                f"üë§ {video_info['uploader']}\n"
                f"‚è±Ô∏è {video_info['duration']} —Å–µ–∫\n\n"
                f"üîÑ –ù–∞—á–∏–Ω–∞—é —Å–∫–∞—á–∏–≤–∞–Ω–∏–µ..."
            )
            await processing_msg.edit_text(info_text)

        # Download video
        video_path = await video_processor.download_video(video_url)

        if video_path and Path(video_path).exists():
            # Check file size
            file_size = Path(video_path).stat().st_size
            max_size = 50 * 1024 * 1024  # 50MB

            if file_size > max_size:
                await processing_msg.edit_text(
                    f"‚ùå –í–∏–¥–µ–æ —Å–ª–∏—à–∫–æ–º –±–æ–ª—å—à–æ–µ ({file_size // (1024*1024)}MB).\n"
                    f"Telegram –æ–≥—Ä–∞–Ω–∏—á–∏–≤–∞–µ—Ç —Ä–∞–∑–º–µ—Ä —Ñ–∞–π–ª–∞ –¥–æ 50MB."
                )
            else:
                # Send video
                await processing_msg.edit_text("üì§ –û—Ç–ø—Ä–∞–≤–ª—è—é –≤–∏–¥–µ–æ...")
                await update.message.reply_video(
                    video=open(video_path, "rb"), caption="‚úÖ –í–∏–¥–µ–æ —É—Å–ø–µ—à–Ω–æ —Å–∫–∞—á–∞–Ω–æ!"
                )
                await processing_msg.delete()

            # Clean up file
            if Path(video_path).exists():
                try:
                    Path(video_path).unlink()
                    logger.info(f"Cleaned up video file: {video_path}")
                except Exception as e:
                    logger.error(f"Error cleaning up file {video_path}: {e}")

        else:
            await processing_msg.edit_text(
                "‚ùå –ù–µ —É–¥–∞–ª–æ—Å—å —Å–∫–∞—á–∞—Ç—å –≤–∏–¥–µ–æ. –ü—Ä–æ–≤–µ—Ä—å—Ç–µ —Å—Å—ã–ª–∫—É."
            )

    except Exception as e:
        logger.error(f"Error in video download: {e}")
        await processing_msg.edit_text("‚ùå –ü—Ä–æ–∏–∑–æ—à–ª–∞ –æ—à–∏–±–∫–∞ –ø—Ä–∏ —Å–∫–∞—á–∏–≤–∞–Ω–∏–∏ –≤–∏–¥–µ–æ.")


async def handle_video_download_trim(
    update: Update, video_url: str, start_time: int, end_time: int
) -> None:
    """
    Simplified video download and trim handler for LLM integration.

    Args:
        update: Telegram update
        video_url: Video URL to download
        start_time: Start time in seconds
        end_time: End time in seconds
    """
    user = update.effective_user

    logger.info(
        f"LLM-triggered download+trim from {user.id}: {video_url} ({start_time}s - {end_time}s)"
    )

    # Start processing
    processing_msg = await update.message.reply_text("‚è≥ –û–±—Ä–∞–±–∞—Ç—ã–≤–∞—é –≤–∏–¥–µ–æ...")

    try:
        # Get video info first
        video_info = await video_processor.get_video_info(video_url)
        if video_info:
            info_text = (
                f"üìπ –ù–∞–π–¥–µ–Ω–æ –≤–∏–¥–µ–æ:\n"
                f"üé¨ {video_info['title']}\n"
                f"‚è±Ô∏è –û–±—Ä–µ–∑–∫–∞: {start_time}—Å–µ–∫ - {end_time}—Å–µ–∫\n\n"
                f"üîÑ –ù–∞—á–∏–Ω–∞—é —Å–∫–∞—á–∏–≤–∞–Ω–∏–µ..."
            )
            await processing_msg.edit_text(info_text)

        # Download video
        video_path = await video_processor.download_video(video_url)

        if video_path and Path(video_path).exists():
            await processing_msg.edit_text("‚úÇÔ∏è –û–±—Ä–µ–∑–∞—é –≤–∏–¥–µ–æ...")

            # Trim video
            trimmed_path = await video_processor.trim_video(
                video_path, start_time, end_time
            )

            if trimmed_path and Path(trimmed_path).exists():
                # Check file size
                file_size = Path(trimmed_path).stat().st_size
                max_size = 50 * 1024 * 1024  # 50MB

                if file_size > max_size:
                    await processing_msg.edit_text(
                        f"‚ùå –û–±—Ä–µ–∑–∞–Ω–Ω–æ–µ –≤–∏–¥–µ–æ —Å–ª–∏—à–∫–æ–º –±–æ–ª—å—à–æ–µ ({file_size // (1024*1024)}MB).\n"
                        f"–ü–æ–ø—Ä–æ–±—É–π—Ç–µ –º–µ–Ω—å—à–∏–π –≤—Ä–µ–º–µ–Ω–Ω–æ–π –∏–Ω—Ç–µ—Ä–≤–∞–ª."
                    )
                else:
                    # Send trimmed video
                    await processing_msg.edit_text("üì§ –û—Ç–ø—Ä–∞–≤–ª—è—é –æ–±—Ä–µ–∑–∞–Ω–Ω–æ–µ –≤–∏–¥–µ–æ...")
                    await update.message.reply_video(
                        video=open(trimmed_path, "rb"),
                        caption=f"‚úÖ –í–∏–¥–µ–æ –æ–±—Ä–µ–∑–∞–Ω–æ —Å {start_time} –ø–æ {end_time} —Å–µ–∫—É–Ω–¥—É!",
                    )
                    await processing_msg.delete()

                # Clean up files
                for path in [video_path, trimmed_path]:
                    if path and Path(path).exists():
                        try:
                            Path(path).unlink()
                            logger.info(f"Cleaned up file: {path}")
                        except Exception as e:
                            logger.error(f"Error cleaning up file {path}: {e}")

            else:
                await processing_msg.edit_text(
                    "‚ùå –ù–µ —É–¥–∞–ª–æ—Å—å –æ–±—Ä–µ–∑–∞—Ç—å –≤–∏–¥–µ–æ. –ü—Ä–æ–≤–µ—Ä—å—Ç–µ –≤—Ä–µ–º–µ–Ω–Ω–æ–π –∏–Ω—Ç–µ—Ä–≤–∞–ª."
                )
        else:
            await processing_msg.edit_text(
                "‚ùå –ù–µ —É–¥–∞–ª–æ—Å—å —Å–∫–∞—á–∞—Ç—å –≤–∏–¥–µ–æ. –ü—Ä–æ–≤–µ—Ä—å—Ç–µ —Å—Å—ã–ª–∫—É."
            )

    except Exception as e:
        logger.error(f"Error in video download+trim: {e}")
        await processing_msg.edit_text("‚ùå –ü—Ä–æ–∏–∑–æ—à–ª–∞ –æ—à–∏–±–∫–∞ –ø—Ä–∏ –æ–±—Ä–∞–±–æ—Ç–∫–µ –≤–∏–¥–µ–æ.")


def contains_trim_request(text: str) -> bool:
    """
    Check if text contains trim request.

    Args:
        text: Text to check

    Returns:
        True if contains trim request
    """
    text_lower = text.lower()
    trim_keywords = [
        "–æ–±—Ä–µ–∂—å",
        "–æ–±—Ä–µ–∑–∞—Ç—å",
        "trim",
        "cut",
        "—Å ",
        "–æ—Ç ",
        "–ø–æ ",
        "–¥–æ ",
        "—Å–µ–∫—É–Ω–¥",
        "–º–∏–Ω—É—Ç",
        "—Å–µ–∫",
        "–º–∏–Ω",
    ]

    return any(keyword in text_lower for keyword in trim_keywords)


async def handle_video_request(update: Update, text: str) -> None:
    """
    Handle video download request.

    Args:
        update: Telegram update
        text: Message text containing video URL
    """
    user = update.effective_user
    video_url = extract_video_url(text)

    if not video_url:
        await update.message.reply_text("‚ùå –ù–µ —É–¥–∞–ª–æ—Å—å –Ω–∞–π—Ç–∏ —Å—Å—ã–ª–∫—É –Ω–∞ –≤–∏–¥–µ–æ")
        return

    logger.info(f"Processing video request from {user.id}: {video_url}")

    # Send processing message
    processing_msg = await update.message.reply_text(
        "‚è≥ –°–∫–∞—á–∏–≤–∞—é –≤–∏–¥–µ–æ... –ü–æ–∂–∞–ª—É–π—Å—Ç–∞, –ø–æ–¥–æ–∂–¥–∏—Ç–µ."
    )

    try:
        # Get video info first
        video_info = await video_processor.get_video_info(video_url)
        if video_info:
            info_text = (
                f"üìπ –ù–∞–π–¥–µ–Ω–æ –≤–∏–¥–µ–æ:\n"
                f"üé¨ {video_info['title']}\n"
                f"üë§ {video_info['uploader']}\n"
                f"‚è±Ô∏è {video_info['duration']} —Å–µ–∫\n"
                f"üìÅ ~{video_info['filesize'] // (1024*1024) if video_info['filesize'] else '?'} MB\n\n"
                f"üîÑ –ù–∞—á–∏–Ω–∞—é —Å–∫–∞—á–∏–≤–∞–Ω–∏–µ..."
            )
            await processing_msg.edit_text(info_text)
        else:
            await processing_msg.edit_text("üîç –ü–æ–ª—É—á–∞—é –∏–Ω—Ñ–æ—Ä–º–∞—Ü–∏—é –æ –≤–∏–¥–µ–æ...")

        # Download video
        video_path = await video_processor.download_video(video_url)

        if video_path and Path(video_path).exists():
            # Check file size for Telegram limits
            file_size = Path(video_path).stat().st_size
            max_size = 50 * 1024 * 1024  # 50MB for Telegram

            if file_size > max_size:
                await processing_msg.edit_text(
                    f"‚ùå –í–∏–¥–µ–æ —Å–ª–∏—à–∫–æ–º –±–æ–ª—å—à–æ–µ ({file_size // (1024*1024)}MB).\n"
                    f"Telegram –æ–≥—Ä–∞–Ω–∏—á–∏–≤–∞–µ—Ç —Ä–∞–∑–º–µ—Ä —Ñ–∞–π–ª–∞ –¥–æ 50MB.\n"
                    f"–ü–æ–ø—Ä–æ–±—É–π—Ç–µ –¥—Ä—É–≥–æ–µ –≤–∏–¥–µ–æ –∏–ª–∏ –æ–±—Ä–µ–∂—å—Ç–µ —ç—Ç–æ."
                )
            else:
                # Send video
                await processing_msg.edit_text("üì§ –û—Ç–ø—Ä–∞–≤–ª—è—é –≤–∏–¥–µ–æ...")
                await update.message.reply_video(
                    video=open(video_path, "rb"), caption="‚úÖ –í–∏–¥–µ–æ —É—Å–ø–µ—à–Ω–æ —Å–∫–∞—á–∞–Ω–æ!"
                )
                await processing_msg.delete()

            # Clean up file
            try:
                Path(video_path).unlink()
                logger.info(f"Cleaned up video file: {video_path}")
            except Exception as e:
                logger.error(f"Error cleaning up file {video_path}: {e}")

        else:
            await processing_msg.edit_text(
                "‚ùå –ù–µ —É–¥–∞–ª–æ—Å—å —Å–∫–∞—á–∞—Ç—å –≤–∏–¥–µ–æ. –ü—Ä–æ–≤–µ—Ä—å—Ç–µ —Å—Å—ã–ª–∫—É –∏ –ø–æ–ø—Ä–æ–±—É–π—Ç–µ –µ—â–µ —Ä–∞–∑."
            )

    except Exception as e:
        logger.error(f"Error processing video request: {e}")
        await processing_msg.edit_text(
            "‚ùå –ü—Ä–æ–∏–∑–æ—à–ª–∞ –æ—à–∏–±–∫–∞ –ø—Ä–∏ –æ–±—Ä–∞–±–æ—Ç–∫–µ –≤–∏–¥–µ–æ. –ü–æ–ø—Ä–æ–±—É–π—Ç–µ –µ—â–µ —Ä–∞–∑."
        )


async def handle_trim_request(update: Update, text: str) -> None:
    """
    Handle video trim request.

    Args:
        update: Telegram update
        text: Message text containing trim request
    """
    user = update.effective_user

    logger.info(f"Processing trim request from {user.id}: {text}")

    # Check if there's a video URL in the message
    video_url = extract_video_url(text)

    if video_url:
        # Combined request: download and trim
        await handle_combined_request(update, text, video_url)
    else:
        # Trim request without URL - ask for video
        await update.message.reply_text(
            "‚ùå –ù–µ –Ω–∞–π–¥–µ–Ω–∞ —Å—Å—ã–ª–∫–∞ –Ω–∞ –≤–∏–¥–µ–æ –¥–ª—è –æ–±—Ä–µ–∑–∫–∏.\n\n"
            "–û—Ç–ø—Ä–∞–≤—å—Ç–µ —Å–æ–æ–±—â–µ–Ω–∏–µ –≤ —Ñ–æ—Ä–º–∞—Ç–µ:\n"
            "‚Ä¢ https://video-url.com –æ–±—Ä–µ–∂—å —Å 10 –ø–æ 20\n"
            "‚Ä¢ –°–∫–∞—á–∞–π https://video-url.com –∏ –æ–±—Ä–µ–∂—å —Å 1:30 –¥–æ 2:45"
        )


async def handle_combined_request(update: Update, text: str, video_url: str) -> None:
    """
    Handle combined download and trim request.

    Args:
        update: Telegram update
        text: Full message text
        video_url: Extracted video URL
    """
    user = update.effective_user

    # Parse time range from text
    time_range = video_processor.parse_time_request(text)
    if not time_range:
        await update.message.reply_text(
            "‚ùå –ù–µ —É–¥–∞–ª–æ—Å—å —Ä–∞—Å–ø–æ–∑–Ω–∞—Ç—å –≤—Ä–µ–º–µ–Ω–Ω–æ–π –∏–Ω—Ç–µ—Ä–≤–∞–ª.\n\n"
            "–ò—Å–ø–æ–ª—å–∑—É–π—Ç–µ —Ñ–æ—Ä–º–∞—Ç—ã:\n"
            "‚Ä¢ —Å 10 –ø–æ 20 —Å–µ–∫—É–Ω–¥—É\n"
            "‚Ä¢ –æ—Ç 1:30 –¥–æ 2:45\n"
            "‚Ä¢ —Å 10 –¥–æ 20"
        )
        return

    start_time, end_time = time_range
    logger.info(f"Parsed time range for trimming: {start_time}s - {end_time}s")

    # Start processing
    processing_msg = await update.message.reply_text(
        "‚è≥ –û–±—Ä–∞–±–∞—Ç—ã–≤–∞—é –∑–∞–ø—Ä–æ—Å –Ω–∞ –æ–±—Ä–µ–∑–∫—É –≤–∏–¥–µ–æ..."
    )

    try:
        # Get video info first
        video_info = await video_processor.get_video_info(video_url)
        if video_info:
            info_text = (
                f"üìπ –ù–∞–π–¥–µ–Ω–æ –≤–∏–¥–µ–æ:\n"
                f"üé¨ {video_info['title']}\n"
                f"‚è±Ô∏è –û–±—Ä–µ–∑–∫–∞: {start_time}—Å–µ–∫ - {end_time}—Å–µ–∫\n\n"
                f"üîÑ –ù–∞—á–∏–Ω–∞—é —Å–∫–∞—á–∏–≤–∞–Ω–∏–µ –∏ –æ–±—Ä–µ–∑–∫—É..."
            )
            await processing_msg.edit_text(info_text)
        else:
            await processing_msg.edit_text("üîç –ü–æ–ª—É—á–∞—é –∏–Ω—Ñ–æ—Ä–º–∞—Ü–∏—é –æ –≤–∏–¥–µ–æ...")

        # Download video
        video_path = await video_processor.download_video(video_url)

        if video_path and Path(video_path).exists():
            await processing_msg.edit_text("‚úÇÔ∏è –û–±—Ä–µ–∑–∞—é –≤–∏–¥–µ–æ...")

            # Trim video
            trimmed_path = await video_processor.trim_video(
                video_path, start_time, end_time
            )

            if trimmed_path and Path(trimmed_path).exists():
                # Check file size
                file_size = Path(trimmed_path).stat().st_size
                max_size = 50 * 1024 * 1024  # 50MB

                if file_size > max_size:
                    await processing_msg.edit_text(
                        f"‚ùå –û–±—Ä–µ–∑–∞–Ω–Ω–æ–µ –≤–∏–¥–µ–æ —Å–ª–∏—à–∫–æ–º –±–æ–ª—å—à–æ–µ ({file_size // (1024*1024)}MB).\n"
                        f"–ü–æ–ø—Ä–æ–±—É–π—Ç–µ –º–µ–Ω—å—à–∏–π –≤—Ä–µ–º–µ–Ω–Ω–æ–π –∏–Ω—Ç–µ—Ä–≤–∞–ª."
                    )
                else:
                    # Send trimmed video
                    await processing_msg.edit_text("üì§ –û—Ç–ø—Ä–∞–≤–ª—è—é –æ–±—Ä–µ–∑–∞–Ω–Ω–æ–µ –≤–∏–¥–µ–æ...")
                    await update.message.reply_video(
                        video=open(trimmed_path, "rb"),
                        caption=f"‚úÖ –í–∏–¥–µ–æ –æ–±—Ä–µ–∑–∞–Ω–æ —Å {start_time} –ø–æ {end_time} —Å–µ–∫—É–Ω–¥—É!",
                    )
                    await processing_msg.delete()

                # Clean up files
                for path in [video_path, trimmed_path]:
                    if path and Path(path).exists():
                        try:
                            Path(path).unlink()
                            logger.info(f"Cleaned up file: {path}")
                        except Exception as e:
                            logger.error(f"Error cleaning up file {path}: {e}")

            else:
                await processing_msg.edit_text(
                    "‚ùå –ù–µ —É–¥–∞–ª–æ—Å—å –æ–±—Ä–µ–∑–∞—Ç—å –≤–∏–¥–µ–æ. –ü—Ä–æ–≤–µ—Ä—å—Ç–µ –≤—Ä–µ–º–µ–Ω–Ω–æ–π –∏–Ω—Ç–µ—Ä–≤–∞–ª."
                )
        else:
            await processing_msg.edit_text(
                "‚ùå –ù–µ —É–¥–∞–ª–æ—Å—å —Å–∫–∞—á–∞—Ç—å –≤–∏–¥–µ–æ. –ü—Ä–æ–≤–µ—Ä—å—Ç–µ —Å—Å—ã–ª–∫—É."
            )

    except Exception as e:
        logger.error(f"Error processing combined request: {e}")
        await processing_msg.edit_text(
            "‚ùå –ü—Ä–æ–∏–∑–æ—à–ª–∞ –æ—à–∏–±–∫–∞ –ø—Ä–∏ –æ–±—Ä–∞–±–æ—Ç–∫–µ –∑–∞–ø—Ä–æ—Å–∞. –ü–æ–ø—Ä–æ–±—É–π—Ç–µ –µ—â–µ —Ä–∞–∑."
        )


async def error_handler(update: Update, context: ContextTypes.DEFAULT_TYPE) -> None:
    """
    Handle errors in the bot.
    """
    logger.error(f"Update {update} caused error: {context.error}")

    # Try to send error message to user
    if update and update.effective_chat:
        try:
            await update.effective_chat.send_message(
                "‚ùå –ü—Ä–æ–∏–∑–æ—à–ª–∞ –æ—à–∏–±–∫–∞. –ü–æ–ø—Ä–æ–±—É–π—Ç–µ –µ—â–µ —Ä–∞–∑ –∏–ª–∏ –∏—Å–ø–æ–ª—å–∑—É–π—Ç–µ /help"
            )
        except Exception as e:
            logger.error(f"Failed to send error message: {e}")


def run_bot() -> None:
    """
    Run the Telegram bot.
    """
    if not TELEGRAM_BOT_TOKEN:
        raise ValueError("TELEGRAM_BOT_TOKEN is not set")

    # Create application
    application = Application.builder().token(TELEGRAM_BOT_TOKEN).build()

    # Add handlers
    application.add_handler(CommandHandler("start", start_command))
    application.add_handler(CommandHandler("help", help_command))
    application.add_handler(
        MessageHandler(filters.TEXT & ~filters.COMMAND, handle_message)
    )

    logger.info("Bot is running...")

    # Run the bot (v20.7 API)
    try:
        application.run_polling()
    except Exception as e:
        logger.error(f"Bot polling error: {e}")
